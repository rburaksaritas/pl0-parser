Grammar

    0 $accept: program $end

    1 program: block DOT

    2 block: constDecl varDecl procDecl funcDecl statement

    3 constDecl: CONST constAssignmentList SEMICOLON
    4          | /* empty */

    5 constAssignmentList: IDENTIFIER EQ NUMBER
    6                    | constAssignmentList COMMA IDENTIFIER ASSIGN NUMBER
    7                    | error

    8 varDecl: VAR identifierList SEMICOLON varDecl
    9        | VAR arrayDecl SEMICOLON varDecl
   10        | /* empty */
   11        | error

   12 identifierList: IDENTIFIER
   13               | identifierList COMMA IDENTIFIER
   14               | error

   15 arrayDecl: IDENTIFIER LBRACKET NUMBER RBRACKET

   16 procDecl: procDecl PROCEDURE IDENTIFIER SEMICOLON block SEMICOLON
   17         | /* empty */

   18 funcDecl: funcDecl FUNCTION IDENTIFIER LPAREN paramList RPAREN SEMICOLON block SEMICOLON
   19         | /* empty */

   20 paramList: paramDecl
   21          | paramList COMMA paramDecl
   22          | /* empty */

   23 paramDecl: VAR IDENTIFIER
   24          | error

   25 statementList: statement
   26              | statementList SEMICOLON statement
   27              | error

   28 statement: matched_statement
   29          | unmatched_statement

   30 matched_statement: IF condition THEN matched_statement ELSE matched_statement
   31                  | non_if_statement
   32                  | WHILE condition DO matched_statement
   33                  | FOR IDENTIFIER ASSIGN expression TO expression DO matched_statement

   34 unmatched_statement: IF condition THEN statement
   35                    | IF condition THEN matched_statement ELSE unmatched_statement
   36                    | WHILE condition DO unmatched_statement
   37                    | FOR IDENTIFIER ASSIGN expression TO expression DO unmatched_statement

   38 non_if_statement: IDENTIFIER ASSIGN expression
   39                 | CALL IDENTIFIER
   40                 | T_BEGIN statementList T_END
   41                 | BREAK
   42                 | arrayAssignment
   43                 | funcCall
   44                 | readWriteStmt
   45                 | RETURN expression
   46                 | RETURN
   47                 | /* empty */

   48 arrayAssignment: IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression

   49 funcCall: IDENTIFIER LPAREN argList RPAREN

   50 readWriteStmt: readStmt
   51              | writeStmt
   52              | writeLineStmt

   53 readStmt: READ LPAREN IDENTIFIER RPAREN

   54 writeStmt: WRITE LPAREN IDENTIFIER RPAREN

   55 writeLineStmt: WRITELINE LPAREN IDENTIFIER RPAREN

   56 condition: ODD expression
   57          | expression EQ expression
   58          | expression NE expression
   59          | expression LT expression
   60          | expression GT expression
   61          | expression LE expression
   62          | expression GE expression

   63 expression: term
   64           | ADD term
   65           | SUB term
   66           | expression ADD term
   67           | expression SUB term
   68           | UMINUS expression
   69           | funcCall

   70 term: factor
   71     | term MUL factor
   72     | term DIV factor
   73     | term MOD factor

   74 factor: IDENTIFIER
   75       | NUMBER
   76       | LPAREN expression RPAREN
   77       | arrayIndex

   78 arrayIndex: IDENTIFIER LBRACKET expression RBRACKET

   79 argList: expression
   80        | argList COMMA expression
   81        | /* empty */


Terminals, with rules where they appear

$end (0) 0
error (256) 7 11 14 24 27
IDENTIFIER (258) 5 6 12 13 15 16 18 23 33 37 38 39 48 49 53 54 55 74
    78
NUMBER (259) 5 6 15 75
CONST (260) 3
VAR (261) 8 9 23
PROCEDURE (262) 16
FUNCTION (263) 18
T_BEGIN (264) 40
T_END (265) 40
CALL (266) 39
IF (267) 30 34 35
THEN (268) 30 34 35
ELSE (269) 30 35
WHILE (270) 32 36
DO (271) 32 33 36 37
FOR (272) 33 37
BREAK (273) 41
READ (274) 53
WRITE (275) 54
WRITELINE (276) 55
RETURN (277) 45 46
ODD (278) 56
TO (279) 33 37
DOT (280) 1
EQ (281) 5 57
NE (282) 58
LT (283) 59
GT (284) 60
LE (285) 61
GE (286) 62
LPAREN (287) 18 49 53 54 55 76
RPAREN (288) 18 49 53 54 55 76
LBRACKET (289) 15 48 78
RBRACKET (290) 15 48 78
COMMA (291) 6 13 21 80
SEMICOLON (292) 3 8 9 16 18 26
ASSIGN (293) 6 33 37 38 48
ADD (294) 64 66
SUB (295) 65 67
MUL (296) 71
DIV (297) 72
MOD (298) 73
UMINUS (299) 68


Nonterminals, with rules where they appear

$accept (45)
    on left: 0
program (46)
    on left: 1, on right: 0
block (47)
    on left: 2, on right: 1 16 18
constDecl (48)
    on left: 3 4, on right: 2
constAssignmentList (49)
    on left: 5 6 7, on right: 3 6
varDecl (50)
    on left: 8 9 10 11, on right: 2 8 9
identifierList (51)
    on left: 12 13 14, on right: 8 13
arrayDecl (52)
    on left: 15, on right: 9
procDecl (53)
    on left: 16 17, on right: 2 16
funcDecl (54)
    on left: 18 19, on right: 2 18
paramList (55)
    on left: 20 21 22, on right: 18 21
paramDecl (56)
    on left: 23 24, on right: 20 21
statementList (57)
    on left: 25 26 27, on right: 26 40
statement (58)
    on left: 28 29, on right: 2 25 26 34
matched_statement (59)
    on left: 30 31 32 33, on right: 28 30 32 33 35
unmatched_statement (60)
    on left: 34 35 36 37, on right: 29 35 36 37
non_if_statement (61)
    on left: 38 39 40 41 42 43 44 45 46 47, on right: 31
arrayAssignment (62)
    on left: 48, on right: 42
funcCall (63)
    on left: 49, on right: 43 69
readWriteStmt (64)
    on left: 50 51 52, on right: 44
readStmt (65)
    on left: 53, on right: 50
writeStmt (66)
    on left: 54, on right: 51
writeLineStmt (67)
    on left: 55, on right: 52
condition (68)
    on left: 56 57 58 59 60 61 62, on right: 30 32 34 35 36
expression (69)
    on left: 63 64 65 66 67 68 69, on right: 33 37 38 45 48 56 57 58
    59 60 61 62 66 67 68 76 78 79 80
term (70)
    on left: 70 71 72 73, on right: 63 64 65 66 67 71 72 73
factor (71)
    on left: 74 75 76 77, on right: 70 71 72 73
arrayIndex (72)
    on left: 78, on right: 77
argList (73)
    on left: 79 80 81, on right: 49 80


state 0

    0 $accept: . program $end

    CONST  shift, and go to state 1

    $default  reduce using rule 4 (constDecl)

    program    go to state 2
    block      go to state 3
    constDecl  go to state 4


state 1

    3 constDecl: CONST . constAssignmentList SEMICOLON

    error       shift, and go to state 5
    IDENTIFIER  shift, and go to state 6

    constAssignmentList  go to state 7


state 2

    0 $accept: program . $end

    $end  shift, and go to state 8


state 3

    1 program: block . DOT

    DOT  shift, and go to state 9


state 4

    2 block: constDecl . varDecl procDecl funcDecl statement

    error  shift, and go to state 10
    VAR    shift, and go to state 11

    IDENTIFIER  reduce using rule 10 (varDecl)
    PROCEDURE   reduce using rule 10 (varDecl)
    FUNCTION    reduce using rule 10 (varDecl)
    T_BEGIN     reduce using rule 10 (varDecl)
    CALL        reduce using rule 10 (varDecl)
    IF          reduce using rule 10 (varDecl)
    WHILE       reduce using rule 10 (varDecl)
    FOR         reduce using rule 10 (varDecl)
    BREAK       reduce using rule 10 (varDecl)
    READ        reduce using rule 10 (varDecl)
    WRITE       reduce using rule 10 (varDecl)
    WRITELINE   reduce using rule 10 (varDecl)
    RETURN      reduce using rule 10 (varDecl)
    DOT         reduce using rule 10 (varDecl)
    SEMICOLON   reduce using rule 10 (varDecl)

    varDecl  go to state 12


state 5

    7 constAssignmentList: error .

    $default  reduce using rule 7 (constAssignmentList)


state 6

    5 constAssignmentList: IDENTIFIER . EQ NUMBER

    EQ  shift, and go to state 13


state 7

    3 constDecl: CONST constAssignmentList . SEMICOLON
    6 constAssignmentList: constAssignmentList . COMMA IDENTIFIER ASSIGN NUMBER

    COMMA      shift, and go to state 14
    SEMICOLON  shift, and go to state 15


state 8

    0 $accept: program $end .

    $default  accept


state 9

    1 program: block DOT .

    $default  reduce using rule 1 (program)


state 10

   11 varDecl: error .

    $default  reduce using rule 11 (varDecl)


state 11

    8 varDecl: VAR . identifierList SEMICOLON varDecl
    9        | VAR . arrayDecl SEMICOLON varDecl

    error       shift, and go to state 16
    IDENTIFIER  shift, and go to state 17

    identifierList  go to state 18
    arrayDecl       go to state 19


state 12

    2 block: constDecl varDecl . procDecl funcDecl statement

    $default  reduce using rule 17 (procDecl)

    procDecl  go to state 20


state 13

    5 constAssignmentList: IDENTIFIER EQ . NUMBER

    NUMBER  shift, and go to state 21


state 14

    6 constAssignmentList: constAssignmentList COMMA . IDENTIFIER ASSIGN NUMBER

    IDENTIFIER  shift, and go to state 22


state 15

    3 constDecl: CONST constAssignmentList SEMICOLON .

    $default  reduce using rule 3 (constDecl)


state 16

   14 identifierList: error .

    $default  reduce using rule 14 (identifierList)


state 17

   12 identifierList: IDENTIFIER .
   15 arrayDecl: IDENTIFIER . LBRACKET NUMBER RBRACKET

    LBRACKET  shift, and go to state 23

    $default  reduce using rule 12 (identifierList)


state 18

    8 varDecl: VAR identifierList . SEMICOLON varDecl
   13 identifierList: identifierList . COMMA IDENTIFIER

    COMMA      shift, and go to state 24
    SEMICOLON  shift, and go to state 25


state 19

    9 varDecl: VAR arrayDecl . SEMICOLON varDecl

    SEMICOLON  shift, and go to state 26


state 20

    2 block: constDecl varDecl procDecl . funcDecl statement
   16 procDecl: procDecl . PROCEDURE IDENTIFIER SEMICOLON block SEMICOLON

    PROCEDURE  shift, and go to state 27

    $default  reduce using rule 19 (funcDecl)

    funcDecl  go to state 28


state 21

    5 constAssignmentList: IDENTIFIER EQ NUMBER .

    $default  reduce using rule 5 (constAssignmentList)


state 22

    6 constAssignmentList: constAssignmentList COMMA IDENTIFIER . ASSIGN NUMBER

    ASSIGN  shift, and go to state 29


state 23

   15 arrayDecl: IDENTIFIER LBRACKET . NUMBER RBRACKET

    NUMBER  shift, and go to state 30


state 24

   13 identifierList: identifierList COMMA . IDENTIFIER

    IDENTIFIER  shift, and go to state 31


state 25

    8 varDecl: VAR identifierList SEMICOLON . varDecl

    error  shift, and go to state 10
    VAR    shift, and go to state 11

    IDENTIFIER  reduce using rule 10 (varDecl)
    PROCEDURE   reduce using rule 10 (varDecl)
    FUNCTION    reduce using rule 10 (varDecl)
    T_BEGIN     reduce using rule 10 (varDecl)
    CALL        reduce using rule 10 (varDecl)
    IF          reduce using rule 10 (varDecl)
    WHILE       reduce using rule 10 (varDecl)
    FOR         reduce using rule 10 (varDecl)
    BREAK       reduce using rule 10 (varDecl)
    READ        reduce using rule 10 (varDecl)
    WRITE       reduce using rule 10 (varDecl)
    WRITELINE   reduce using rule 10 (varDecl)
    RETURN      reduce using rule 10 (varDecl)
    DOT         reduce using rule 10 (varDecl)
    SEMICOLON   reduce using rule 10 (varDecl)

    varDecl  go to state 32


state 26

    9 varDecl: VAR arrayDecl SEMICOLON . varDecl

    error  shift, and go to state 10
    VAR    shift, and go to state 11

    IDENTIFIER  reduce using rule 10 (varDecl)
    PROCEDURE   reduce using rule 10 (varDecl)
    FUNCTION    reduce using rule 10 (varDecl)
    T_BEGIN     reduce using rule 10 (varDecl)
    CALL        reduce using rule 10 (varDecl)
    IF          reduce using rule 10 (varDecl)
    WHILE       reduce using rule 10 (varDecl)
    FOR         reduce using rule 10 (varDecl)
    BREAK       reduce using rule 10 (varDecl)
    READ        reduce using rule 10 (varDecl)
    WRITE       reduce using rule 10 (varDecl)
    WRITELINE   reduce using rule 10 (varDecl)
    RETURN      reduce using rule 10 (varDecl)
    DOT         reduce using rule 10 (varDecl)
    SEMICOLON   reduce using rule 10 (varDecl)

    varDecl  go to state 33


state 27

   16 procDecl: procDecl PROCEDURE . IDENTIFIER SEMICOLON block SEMICOLON

    IDENTIFIER  shift, and go to state 34


state 28

    2 block: constDecl varDecl procDecl funcDecl . statement
   18 funcDecl: funcDecl . FUNCTION IDENTIFIER LPAREN paramList RPAREN SEMICOLON block SEMICOLON

    IDENTIFIER  shift, and go to state 35
    FUNCTION    shift, and go to state 36
    T_BEGIN     shift, and go to state 37
    CALL        shift, and go to state 38
    IF          shift, and go to state 39
    WHILE       shift, and go to state 40
    FOR         shift, and go to state 41
    BREAK       shift, and go to state 42
    READ        shift, and go to state 43
    WRITE       shift, and go to state 44
    WRITELINE   shift, and go to state 45
    RETURN      shift, and go to state 46

    $default  reduce using rule 47 (non_if_statement)

    statement            go to state 47
    matched_statement    go to state 48
    unmatched_statement  go to state 49
    non_if_statement     go to state 50
    arrayAssignment      go to state 51
    funcCall             go to state 52
    readWriteStmt        go to state 53
    readStmt             go to state 54
    writeStmt            go to state 55
    writeLineStmt        go to state 56


state 29

    6 constAssignmentList: constAssignmentList COMMA IDENTIFIER ASSIGN . NUMBER

    NUMBER  shift, and go to state 57


state 30

   15 arrayDecl: IDENTIFIER LBRACKET NUMBER . RBRACKET

    RBRACKET  shift, and go to state 58


state 31

   13 identifierList: identifierList COMMA IDENTIFIER .

    $default  reduce using rule 13 (identifierList)


state 32

    8 varDecl: VAR identifierList SEMICOLON varDecl .

    $default  reduce using rule 8 (varDecl)


state 33

    9 varDecl: VAR arrayDecl SEMICOLON varDecl .

    $default  reduce using rule 9 (varDecl)


state 34

   16 procDecl: procDecl PROCEDURE IDENTIFIER . SEMICOLON block SEMICOLON

    SEMICOLON  shift, and go to state 59


state 35

   38 non_if_statement: IDENTIFIER . ASSIGN expression
   48 arrayAssignment: IDENTIFIER . LBRACKET expression RBRACKET ASSIGN expression
   49 funcCall: IDENTIFIER . LPAREN argList RPAREN

    LPAREN    shift, and go to state 60
    LBRACKET  shift, and go to state 61
    ASSIGN    shift, and go to state 62


state 36

   18 funcDecl: funcDecl FUNCTION . IDENTIFIER LPAREN paramList RPAREN SEMICOLON block SEMICOLON

    IDENTIFIER  shift, and go to state 63


state 37

   40 non_if_statement: T_BEGIN . statementList T_END

    error       shift, and go to state 64
    IDENTIFIER  shift, and go to state 35
    T_BEGIN     shift, and go to state 37
    CALL        shift, and go to state 38
    IF          shift, and go to state 39
    WHILE       shift, and go to state 40
    FOR         shift, and go to state 41
    BREAK       shift, and go to state 42
    READ        shift, and go to state 43
    WRITE       shift, and go to state 44
    WRITELINE   shift, and go to state 45
    RETURN      shift, and go to state 46

    T_END      reduce using rule 47 (non_if_statement)
    SEMICOLON  reduce using rule 47 (non_if_statement)

    statementList        go to state 65
    statement            go to state 66
    matched_statement    go to state 48
    unmatched_statement  go to state 49
    non_if_statement     go to state 50
    arrayAssignment      go to state 51
    funcCall             go to state 52
    readWriteStmt        go to state 53
    readStmt             go to state 54
    writeStmt            go to state 55
    writeLineStmt        go to state 56


state 38

   39 non_if_statement: CALL . IDENTIFIER

    IDENTIFIER  shift, and go to state 67


state 39

   30 matched_statement: IF . condition THEN matched_statement ELSE matched_statement
   34 unmatched_statement: IF . condition THEN statement
   35                    | IF . condition THEN matched_statement ELSE unmatched_statement

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    ODD         shift, and go to state 70
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    condition   go to state 76
    expression  go to state 77
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 40

   32 matched_statement: WHILE . condition DO matched_statement
   36 unmatched_statement: WHILE . condition DO unmatched_statement

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    ODD         shift, and go to state 70
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    condition   go to state 81
    expression  go to state 77
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 41

   33 matched_statement: FOR . IDENTIFIER ASSIGN expression TO expression DO matched_statement
   37 unmatched_statement: FOR . IDENTIFIER ASSIGN expression TO expression DO unmatched_statement

    IDENTIFIER  shift, and go to state 82


state 42

   41 non_if_statement: BREAK .

    $default  reduce using rule 41 (non_if_statement)


state 43

   53 readStmt: READ . LPAREN IDENTIFIER RPAREN

    LPAREN  shift, and go to state 83


state 44

   54 writeStmt: WRITE . LPAREN IDENTIFIER RPAREN

    LPAREN  shift, and go to state 84


state 45

   55 writeLineStmt: WRITELINE . LPAREN IDENTIFIER RPAREN

    LPAREN  shift, and go to state 85


state 46

   45 non_if_statement: RETURN . expression
   46                 | RETURN .

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    $default  reduce using rule 46 (non_if_statement)

    funcCall    go to state 75
    expression  go to state 86
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 47

    2 block: constDecl varDecl procDecl funcDecl statement .

    $default  reduce using rule 2 (block)


state 48

   28 statement: matched_statement .

    $default  reduce using rule 28 (statement)


state 49

   29 statement: unmatched_statement .

    $default  reduce using rule 29 (statement)


state 50

   31 matched_statement: non_if_statement .

    $default  reduce using rule 31 (matched_statement)


state 51

   42 non_if_statement: arrayAssignment .

    $default  reduce using rule 42 (non_if_statement)


state 52

   43 non_if_statement: funcCall .

    $default  reduce using rule 43 (non_if_statement)


state 53

   44 non_if_statement: readWriteStmt .

    $default  reduce using rule 44 (non_if_statement)


state 54

   50 readWriteStmt: readStmt .

    $default  reduce using rule 50 (readWriteStmt)


state 55

   51 readWriteStmt: writeStmt .

    $default  reduce using rule 51 (readWriteStmt)


state 56

   52 readWriteStmt: writeLineStmt .

    $default  reduce using rule 52 (readWriteStmt)


state 57

    6 constAssignmentList: constAssignmentList COMMA IDENTIFIER ASSIGN NUMBER .

    $default  reduce using rule 6 (constAssignmentList)


state 58

   15 arrayDecl: IDENTIFIER LBRACKET NUMBER RBRACKET .

    $default  reduce using rule 15 (arrayDecl)


state 59

   16 procDecl: procDecl PROCEDURE IDENTIFIER SEMICOLON . block SEMICOLON

    CONST  shift, and go to state 1

    $default  reduce using rule 4 (constDecl)

    block      go to state 87
    constDecl  go to state 4


state 60

   49 funcCall: IDENTIFIER LPAREN . argList RPAREN

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    $default  reduce using rule 81 (argList)

    funcCall    go to state 75
    expression  go to state 88
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80
    argList     go to state 89


state 61

   48 arrayAssignment: IDENTIFIER LBRACKET . expression RBRACKET ASSIGN expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 90
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 62

   38 non_if_statement: IDENTIFIER ASSIGN . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 91
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 63

   18 funcDecl: funcDecl FUNCTION IDENTIFIER . LPAREN paramList RPAREN SEMICOLON block SEMICOLON

    LPAREN  shift, and go to state 92


state 64

   27 statementList: error .

    $default  reduce using rule 27 (statementList)


state 65

   26 statementList: statementList . SEMICOLON statement
   40 non_if_statement: T_BEGIN statementList . T_END

    T_END      shift, and go to state 93
    SEMICOLON  shift, and go to state 94


state 66

   25 statementList: statement .

    $default  reduce using rule 25 (statementList)


state 67

   39 non_if_statement: CALL IDENTIFIER .

    $default  reduce using rule 39 (non_if_statement)


state 68

   49 funcCall: IDENTIFIER . LPAREN argList RPAREN
   74 factor: IDENTIFIER .
   78 arrayIndex: IDENTIFIER . LBRACKET expression RBRACKET

    LPAREN    shift, and go to state 60
    LBRACKET  shift, and go to state 95

    $default  reduce using rule 74 (factor)


state 69

   75 factor: NUMBER .

    $default  reduce using rule 75 (factor)


state 70

   56 condition: ODD . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 96
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 71

   76 factor: LPAREN . expression RPAREN

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 97
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 72

   64 expression: ADD . term

    IDENTIFIER  shift, and go to state 98
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71

    term        go to state 99
    factor      go to state 79
    arrayIndex  go to state 80


state 73

   65 expression: SUB . term

    IDENTIFIER  shift, and go to state 98
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71

    term        go to state 100
    factor      go to state 79
    arrayIndex  go to state 80


state 74

   68 expression: UMINUS . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 101
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 75

   69 expression: funcCall .

    $default  reduce using rule 69 (expression)


state 76

   30 matched_statement: IF condition . THEN matched_statement ELSE matched_statement
   34 unmatched_statement: IF condition . THEN statement
   35                    | IF condition . THEN matched_statement ELSE unmatched_statement

    THEN  shift, and go to state 102


state 77

   57 condition: expression . EQ expression
   58          | expression . NE expression
   59          | expression . LT expression
   60          | expression . GT expression
   61          | expression . LE expression
   62          | expression . GE expression
   66 expression: expression . ADD term
   67           | expression . SUB term

    EQ   shift, and go to state 103
    NE   shift, and go to state 104
    LT   shift, and go to state 105
    GT   shift, and go to state 106
    LE   shift, and go to state 107
    GE   shift, and go to state 108
    ADD  shift, and go to state 109
    SUB  shift, and go to state 110


state 78

   63 expression: term .
   71 term: term . MUL factor
   72     | term . DIV factor
   73     | term . MOD factor

    MUL  shift, and go to state 111
    DIV  shift, and go to state 112
    MOD  shift, and go to state 113

    $default  reduce using rule 63 (expression)


state 79

   70 term: factor .

    $default  reduce using rule 70 (term)


state 80

   77 factor: arrayIndex .

    $default  reduce using rule 77 (factor)


state 81

   32 matched_statement: WHILE condition . DO matched_statement
   36 unmatched_statement: WHILE condition . DO unmatched_statement

    DO  shift, and go to state 114


state 82

   33 matched_statement: FOR IDENTIFIER . ASSIGN expression TO expression DO matched_statement
   37 unmatched_statement: FOR IDENTIFIER . ASSIGN expression TO expression DO unmatched_statement

    ASSIGN  shift, and go to state 115


state 83

   53 readStmt: READ LPAREN . IDENTIFIER RPAREN

    IDENTIFIER  shift, and go to state 116


state 84

   54 writeStmt: WRITE LPAREN . IDENTIFIER RPAREN

    IDENTIFIER  shift, and go to state 117


state 85

   55 writeLineStmt: WRITELINE LPAREN . IDENTIFIER RPAREN

    IDENTIFIER  shift, and go to state 118


state 86

   45 non_if_statement: RETURN expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 45 (non_if_statement)


state 87

   16 procDecl: procDecl PROCEDURE IDENTIFIER SEMICOLON block . SEMICOLON

    SEMICOLON  shift, and go to state 119


state 88

   66 expression: expression . ADD term
   67           | expression . SUB term
   79 argList: expression .

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 79 (argList)


state 89

   49 funcCall: IDENTIFIER LPAREN argList . RPAREN
   80 argList: argList . COMMA expression

    RPAREN  shift, and go to state 120
    COMMA   shift, and go to state 121


state 90

   48 arrayAssignment: IDENTIFIER LBRACKET expression . RBRACKET ASSIGN expression
   66 expression: expression . ADD term
   67           | expression . SUB term

    RBRACKET  shift, and go to state 122
    ADD       shift, and go to state 109
    SUB       shift, and go to state 110


state 91

   38 non_if_statement: IDENTIFIER ASSIGN expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 38 (non_if_statement)


state 92

   18 funcDecl: funcDecl FUNCTION IDENTIFIER LPAREN . paramList RPAREN SEMICOLON block SEMICOLON

    error  shift, and go to state 123
    VAR    shift, and go to state 124

    RPAREN  reduce using rule 22 (paramList)
    COMMA   reduce using rule 22 (paramList)

    paramList  go to state 125
    paramDecl  go to state 126


state 93

   40 non_if_statement: T_BEGIN statementList T_END .

    $default  reduce using rule 40 (non_if_statement)


state 94

   26 statementList: statementList SEMICOLON . statement

    IDENTIFIER  shift, and go to state 35
    T_BEGIN     shift, and go to state 37
    CALL        shift, and go to state 38
    IF          shift, and go to state 39
    WHILE       shift, and go to state 40
    FOR         shift, and go to state 41
    BREAK       shift, and go to state 42
    READ        shift, and go to state 43
    WRITE       shift, and go to state 44
    WRITELINE   shift, and go to state 45
    RETURN      shift, and go to state 46

    $default  reduce using rule 47 (non_if_statement)

    statement            go to state 127
    matched_statement    go to state 48
    unmatched_statement  go to state 49
    non_if_statement     go to state 50
    arrayAssignment      go to state 51
    funcCall             go to state 52
    readWriteStmt        go to state 53
    readStmt             go to state 54
    writeStmt            go to state 55
    writeLineStmt        go to state 56


state 95

   78 arrayIndex: IDENTIFIER LBRACKET . expression RBRACKET

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 128
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 96

   56 condition: ODD expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 56 (condition)


state 97

   66 expression: expression . ADD term
   67           | expression . SUB term
   76 factor: LPAREN expression . RPAREN

    RPAREN  shift, and go to state 129
    ADD     shift, and go to state 109
    SUB     shift, and go to state 110


state 98

   74 factor: IDENTIFIER .
   78 arrayIndex: IDENTIFIER . LBRACKET expression RBRACKET

    LBRACKET  shift, and go to state 95

    $default  reduce using rule 74 (factor)


state 99

   64 expression: ADD term .
   71 term: term . MUL factor
   72     | term . DIV factor
   73     | term . MOD factor

    MUL  shift, and go to state 111
    DIV  shift, and go to state 112
    MOD  shift, and go to state 113

    $default  reduce using rule 64 (expression)


state 100

   65 expression: SUB term .
   71 term: term . MUL factor
   72     | term . DIV factor
   73     | term . MOD factor

    MUL  shift, and go to state 111
    DIV  shift, and go to state 112
    MOD  shift, and go to state 113

    $default  reduce using rule 65 (expression)


state 101

   66 expression: expression . ADD term
   67           | expression . SUB term
   68           | UMINUS expression .

    $default  reduce using rule 68 (expression)


state 102

   30 matched_statement: IF condition THEN . matched_statement ELSE matched_statement
   34 unmatched_statement: IF condition THEN . statement
   35                    | IF condition THEN . matched_statement ELSE unmatched_statement

    IDENTIFIER  shift, and go to state 35
    T_BEGIN     shift, and go to state 37
    CALL        shift, and go to state 38
    IF          shift, and go to state 39
    WHILE       shift, and go to state 40
    FOR         shift, and go to state 41
    BREAK       shift, and go to state 42
    READ        shift, and go to state 43
    WRITE       shift, and go to state 44
    WRITELINE   shift, and go to state 45
    RETURN      shift, and go to state 46

    $default  reduce using rule 47 (non_if_statement)

    statement            go to state 130
    matched_statement    go to state 131
    unmatched_statement  go to state 49
    non_if_statement     go to state 50
    arrayAssignment      go to state 51
    funcCall             go to state 52
    readWriteStmt        go to state 53
    readStmt             go to state 54
    writeStmt            go to state 55
    writeLineStmt        go to state 56


state 103

   57 condition: expression EQ . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 132
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 104

   58 condition: expression NE . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 133
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 105

   59 condition: expression LT . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 134
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 106

   60 condition: expression GT . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 135
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 107

   61 condition: expression LE . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 136
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 108

   62 condition: expression GE . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 137
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 109

   66 expression: expression ADD . term

    IDENTIFIER  shift, and go to state 98
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71

    term        go to state 138
    factor      go to state 79
    arrayIndex  go to state 80


state 110

   67 expression: expression SUB . term

    IDENTIFIER  shift, and go to state 98
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71

    term        go to state 139
    factor      go to state 79
    arrayIndex  go to state 80


state 111

   71 term: term MUL . factor

    IDENTIFIER  shift, and go to state 98
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71

    factor      go to state 140
    arrayIndex  go to state 80


state 112

   72 term: term DIV . factor

    IDENTIFIER  shift, and go to state 98
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71

    factor      go to state 141
    arrayIndex  go to state 80


state 113

   73 term: term MOD . factor

    IDENTIFIER  shift, and go to state 98
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71

    factor      go to state 142
    arrayIndex  go to state 80


state 114

   32 matched_statement: WHILE condition DO . matched_statement
   36 unmatched_statement: WHILE condition DO . unmatched_statement

    IDENTIFIER  shift, and go to state 35
    T_BEGIN     shift, and go to state 37
    CALL        shift, and go to state 38
    IF          shift, and go to state 39
    WHILE       shift, and go to state 40
    FOR         shift, and go to state 41
    BREAK       shift, and go to state 42
    READ        shift, and go to state 43
    WRITE       shift, and go to state 44
    WRITELINE   shift, and go to state 45
    RETURN      shift, and go to state 46

    $default  reduce using rule 47 (non_if_statement)

    matched_statement    go to state 143
    unmatched_statement  go to state 144
    non_if_statement     go to state 50
    arrayAssignment      go to state 51
    funcCall             go to state 52
    readWriteStmt        go to state 53
    readStmt             go to state 54
    writeStmt            go to state 55
    writeLineStmt        go to state 56


state 115

   33 matched_statement: FOR IDENTIFIER ASSIGN . expression TO expression DO matched_statement
   37 unmatched_statement: FOR IDENTIFIER ASSIGN . expression TO expression DO unmatched_statement

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 145
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 116

   53 readStmt: READ LPAREN IDENTIFIER . RPAREN

    RPAREN  shift, and go to state 146


state 117

   54 writeStmt: WRITE LPAREN IDENTIFIER . RPAREN

    RPAREN  shift, and go to state 147


state 118

   55 writeLineStmt: WRITELINE LPAREN IDENTIFIER . RPAREN

    RPAREN  shift, and go to state 148


state 119

   16 procDecl: procDecl PROCEDURE IDENTIFIER SEMICOLON block SEMICOLON .

    $default  reduce using rule 16 (procDecl)


state 120

   49 funcCall: IDENTIFIER LPAREN argList RPAREN .

    $default  reduce using rule 49 (funcCall)


state 121

   80 argList: argList COMMA . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 149
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 122

   48 arrayAssignment: IDENTIFIER LBRACKET expression RBRACKET . ASSIGN expression

    ASSIGN  shift, and go to state 150


state 123

   24 paramDecl: error .

    $default  reduce using rule 24 (paramDecl)


state 124

   23 paramDecl: VAR . IDENTIFIER

    IDENTIFIER  shift, and go to state 151


state 125

   18 funcDecl: funcDecl FUNCTION IDENTIFIER LPAREN paramList . RPAREN SEMICOLON block SEMICOLON
   21 paramList: paramList . COMMA paramDecl

    RPAREN  shift, and go to state 152
    COMMA   shift, and go to state 153


state 126

   20 paramList: paramDecl .

    $default  reduce using rule 20 (paramList)


state 127

   26 statementList: statementList SEMICOLON statement .

    $default  reduce using rule 26 (statementList)


state 128

   66 expression: expression . ADD term
   67           | expression . SUB term
   78 arrayIndex: IDENTIFIER LBRACKET expression . RBRACKET

    RBRACKET  shift, and go to state 154
    ADD       shift, and go to state 109
    SUB       shift, and go to state 110


state 129

   76 factor: LPAREN expression RPAREN .

    $default  reduce using rule 76 (factor)


state 130

   34 unmatched_statement: IF condition THEN statement .

    $default  reduce using rule 34 (unmatched_statement)


state 131

   28 statement: matched_statement .
   30 matched_statement: IF condition THEN matched_statement . ELSE matched_statement
   35 unmatched_statement: IF condition THEN matched_statement . ELSE unmatched_statement

    ELSE  shift, and go to state 155

    $default  reduce using rule 28 (statement)


state 132

   57 condition: expression EQ expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 57 (condition)


state 133

   58 condition: expression NE expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 58 (condition)


state 134

   59 condition: expression LT expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 59 (condition)


state 135

   60 condition: expression GT expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 60 (condition)


state 136

   61 condition: expression LE expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 61 (condition)


state 137

   62 condition: expression GE expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 62 (condition)


state 138

   66 expression: expression ADD term .
   71 term: term . MUL factor
   72     | term . DIV factor
   73     | term . MOD factor

    MUL  shift, and go to state 111
    DIV  shift, and go to state 112
    MOD  shift, and go to state 113

    $default  reduce using rule 66 (expression)


state 139

   67 expression: expression SUB term .
   71 term: term . MUL factor
   72     | term . DIV factor
   73     | term . MOD factor

    MUL  shift, and go to state 111
    DIV  shift, and go to state 112
    MOD  shift, and go to state 113

    $default  reduce using rule 67 (expression)


state 140

   71 term: term MUL factor .

    $default  reduce using rule 71 (term)


state 141

   72 term: term DIV factor .

    $default  reduce using rule 72 (term)


state 142

   73 term: term MOD factor .

    $default  reduce using rule 73 (term)


state 143

   32 matched_statement: WHILE condition DO matched_statement .

    $default  reduce using rule 32 (matched_statement)


state 144

   36 unmatched_statement: WHILE condition DO unmatched_statement .

    $default  reduce using rule 36 (unmatched_statement)


state 145

   33 matched_statement: FOR IDENTIFIER ASSIGN expression . TO expression DO matched_statement
   37 unmatched_statement: FOR IDENTIFIER ASSIGN expression . TO expression DO unmatched_statement
   66 expression: expression . ADD term
   67           | expression . SUB term

    TO   shift, and go to state 156
    ADD  shift, and go to state 109
    SUB  shift, and go to state 110


state 146

   53 readStmt: READ LPAREN IDENTIFIER RPAREN .

    $default  reduce using rule 53 (readStmt)


state 147

   54 writeStmt: WRITE LPAREN IDENTIFIER RPAREN .

    $default  reduce using rule 54 (writeStmt)


state 148

   55 writeLineStmt: WRITELINE LPAREN IDENTIFIER RPAREN .

    $default  reduce using rule 55 (writeLineStmt)


state 149

   66 expression: expression . ADD term
   67           | expression . SUB term
   80 argList: argList COMMA expression .

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 80 (argList)


state 150

   48 arrayAssignment: IDENTIFIER LBRACKET expression RBRACKET ASSIGN . expression

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 157
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 151

   23 paramDecl: VAR IDENTIFIER .

    $default  reduce using rule 23 (paramDecl)


state 152

   18 funcDecl: funcDecl FUNCTION IDENTIFIER LPAREN paramList RPAREN . SEMICOLON block SEMICOLON

    SEMICOLON  shift, and go to state 158


state 153

   21 paramList: paramList COMMA . paramDecl

    error  shift, and go to state 123
    VAR    shift, and go to state 124

    paramDecl  go to state 159


state 154

   78 arrayIndex: IDENTIFIER LBRACKET expression RBRACKET .

    $default  reduce using rule 78 (arrayIndex)


state 155

   30 matched_statement: IF condition THEN matched_statement ELSE . matched_statement
   35 unmatched_statement: IF condition THEN matched_statement ELSE . unmatched_statement

    IDENTIFIER  shift, and go to state 35
    T_BEGIN     shift, and go to state 37
    CALL        shift, and go to state 38
    IF          shift, and go to state 39
    WHILE       shift, and go to state 40
    FOR         shift, and go to state 41
    BREAK       shift, and go to state 42
    READ        shift, and go to state 43
    WRITE       shift, and go to state 44
    WRITELINE   shift, and go to state 45
    RETURN      shift, and go to state 46

    $default  reduce using rule 47 (non_if_statement)

    matched_statement    go to state 160
    unmatched_statement  go to state 161
    non_if_statement     go to state 50
    arrayAssignment      go to state 51
    funcCall             go to state 52
    readWriteStmt        go to state 53
    readStmt             go to state 54
    writeStmt            go to state 55
    writeLineStmt        go to state 56


state 156

   33 matched_statement: FOR IDENTIFIER ASSIGN expression TO . expression DO matched_statement
   37 unmatched_statement: FOR IDENTIFIER ASSIGN expression TO . expression DO unmatched_statement

    IDENTIFIER  shift, and go to state 68
    NUMBER      shift, and go to state 69
    LPAREN      shift, and go to state 71
    ADD         shift, and go to state 72
    SUB         shift, and go to state 73
    UMINUS      shift, and go to state 74

    funcCall    go to state 75
    expression  go to state 162
    term        go to state 78
    factor      go to state 79
    arrayIndex  go to state 80


state 157

   48 arrayAssignment: IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression .
   66 expression: expression . ADD term
   67           | expression . SUB term

    ADD  shift, and go to state 109
    SUB  shift, and go to state 110

    $default  reduce using rule 48 (arrayAssignment)


state 158

   18 funcDecl: funcDecl FUNCTION IDENTIFIER LPAREN paramList RPAREN SEMICOLON . block SEMICOLON

    CONST  shift, and go to state 1

    $default  reduce using rule 4 (constDecl)

    block      go to state 163
    constDecl  go to state 4


state 159

   21 paramList: paramList COMMA paramDecl .

    $default  reduce using rule 21 (paramList)


state 160

   30 matched_statement: IF condition THEN matched_statement ELSE matched_statement .

    $default  reduce using rule 30 (matched_statement)


state 161

   35 unmatched_statement: IF condition THEN matched_statement ELSE unmatched_statement .

    $default  reduce using rule 35 (unmatched_statement)


state 162

   33 matched_statement: FOR IDENTIFIER ASSIGN expression TO expression . DO matched_statement
   37 unmatched_statement: FOR IDENTIFIER ASSIGN expression TO expression . DO unmatched_statement
   66 expression: expression . ADD term
   67           | expression . SUB term

    DO   shift, and go to state 164
    ADD  shift, and go to state 109
    SUB  shift, and go to state 110


state 163

   18 funcDecl: funcDecl FUNCTION IDENTIFIER LPAREN paramList RPAREN SEMICOLON block . SEMICOLON

    SEMICOLON  shift, and go to state 165


state 164

   33 matched_statement: FOR IDENTIFIER ASSIGN expression TO expression DO . matched_statement
   37 unmatched_statement: FOR IDENTIFIER ASSIGN expression TO expression DO . unmatched_statement

    IDENTIFIER  shift, and go to state 35
    T_BEGIN     shift, and go to state 37
    CALL        shift, and go to state 38
    IF          shift, and go to state 39
    WHILE       shift, and go to state 40
    FOR         shift, and go to state 41
    BREAK       shift, and go to state 42
    READ        shift, and go to state 43
    WRITE       shift, and go to state 44
    WRITELINE   shift, and go to state 45
    RETURN      shift, and go to state 46

    $default  reduce using rule 47 (non_if_statement)

    matched_statement    go to state 166
    unmatched_statement  go to state 167
    non_if_statement     go to state 50
    arrayAssignment      go to state 51
    funcCall             go to state 52
    readWriteStmt        go to state 53
    readStmt             go to state 54
    writeStmt            go to state 55
    writeLineStmt        go to state 56


state 165

   18 funcDecl: funcDecl FUNCTION IDENTIFIER LPAREN paramList RPAREN SEMICOLON block SEMICOLON .

    $default  reduce using rule 18 (funcDecl)


state 166

   33 matched_statement: FOR IDENTIFIER ASSIGN expression TO expression DO matched_statement .

    $default  reduce using rule 33 (matched_statement)


state 167

   37 unmatched_statement: FOR IDENTIFIER ASSIGN expression TO expression DO unmatched_statement .

    $default  reduce using rule 37 (unmatched_statement)
